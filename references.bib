
@article{Affeldt2008,
  abstract = {Thanks to recent advances, modern proof assistants now enable verification of realistic sequential programs. However, regarding the concurrency paradigm, previous work essentially focused on formalization of abstract systems, such as pure concurrent calculi, which are too minimal to be realistic. In this paper, we propose a library that enables verification of realistic concurrent programs in the Coq proof assistant. Our approach is based on an extension of the {$\pi$}-calculus whose encoding enables such programs to be modeled conveniently. This encoding is coupled with a specification language akin to spatial logics, including in particular a notion of fairness, which is important to write satisfactory specifications for realistic concurrent programs. In order to facilitate formal proof, we propose a collection of lemmas that can be reused in the context of different verifications. Among these lemmas, the most effective for simplifying the proof task take advantage of confluence properties. In order to evaluate feasibility of verification of concurrent programs using this library, we perform verification for a non-trivial application.},
  author = {Affeldt, Reynald and Kobayashi, Naoki},
  doi = {10.1016/j.entcs.2007.11.010},
  file = {/home/uma/references/papers/Affeldt_Kobayashi_2008_A Coq Library for Verification of Concurrent Programs.pdf;/home/uma/.zotero/data/storage/EL75KDDA/S1571066108000765.html},
  issn = {1571-0661},
  journal = {Electronic Notes in Theoretical Computer Science},
  keywords = {concurrent programs,Coq,pi-calculus,Proof assistant},
  month = feb,
  pages = {17-32},
  series = {Proceedings of the {{Fourth International Workshop}} on {{Logical Frameworks}} and {{Meta}}-{{Languages}} ({{LFM}} 2004)},
  title = {A {{Coq Library}} for {{Verification}} of {{Concurrent Programs}}},
  volume = {199},
  year = {2008}
}

@book{Aho1986,
  address = {{Boston, MA, USA}},
  author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  isbn = {0-201-10088-6},
  publisher = {{Addison-Wesley Longman Publishing Co., Inc.}},
  title = {Compilers: {{Principles}}, {{Techniques}}, and {{Tools}}},
  year = {1986}
}

@article{Allais2018,
  author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
  doi = {10.1145/3236785},
  file = {/home/uma/references/papers/Allais et al_2018_A Type and Scope Safe Universe of Syntaxes with Binding.pdf;/home/uma/references/papers/Allais et al_2018_A Type and Scope Safe Universe of Syntaxes with Binding2.pdf},
  issn = {2475-1421},
  journal = {Proc. ACM Program. Lang.},
  keywords = {Agda,Fusion,Generic Programming,Logical Relations,Semantics,Simulation,Syntax with Binding},
  month = jul,
  number = {ICFP},
  pages = {90:1-90:30},
  title = {A {{Type}} and {{Scope Safe Universe}} of {{Syntaxes}} with {{Binding}}: {{Their Semantics}} and {{Proofs}}},
  volume = {2},
  year = {2018}
}

@article{Altenkirch2015,
  abstract = {We show that the syntactically rich notion of strictly positive families can be reduced to a core type theory with a fixed number of type constructors exploiting the novel notion of indexed containers. As a result, we show indexed containers provide normal forms for strictly positive families in much the same way that containers provide normal forms for strictly positive types. Interestingly, this step from containers to indexed containers is achieved without having to extend the core type theory. Most of the construction presented here has been formalized using the Agda system.},
  author = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and Mcbride, Conor and Morris, Peter},
  doi = {10.1017/S095679681500009X},
  file = {/home/uma/references/papers/Altenkirch et al_2015_Indexed containers.pdf},
  journal = {Journal of Functional Programming},
  month = feb,
  title = {Indexed Containers},
  volume = {25},
  year = {2015}
}

@article{Backus1960,
  author = {Backus, J. W. and Bauer, F. L. and Green, J. and Katz, C. and McCarthy, J. and Perlis, A. J. and Rutishauser, H. and Samelson, K. and Vauquois, B. and Wegstein, J. H. and {van Wijngaarden}, A. and Woodger, M.},
  doi = {10.1145/367236.367262},
  editor = {Naur, Peter},
  issn = {0001-0782},
  journal = {Commun. ACM},
  month = may,
  number = {5},
  pages = {299-314},
  title = {Report on the {{Algorithmic Language ALGOL}} 60},
  volume = {3},
  year = {1960}
}

@book{Barendregt1984,
  address = {{Amsterdam ; New York : New York, N.Y}},
  author = {Barendregt, H. P.},
  edition = {Rev. ed},
  isbn = {978-0-444-86748-3 978-0-444-87508-2},
  keywords = {Lambda calculus},
  lccn = {QA9.5 .B36 1984},
  number = {v. 103},
  publisher = {{North-Holland ; Sole distributors for the U.S.A. and Canada, Elsevier Science Pub. Co}},
  series = {Studies in Logic and the Foundations of Mathematics},
  shorttitle = {The Lambda Calculus},
  title = {The Lambda Calculus: Its Syntax and Semantics},
  year = {1984}
}

@article{Black1999,
  abstract = {We formally verify that a particular web server written in C is secure, that is, a remote user cannot get files he shouldn't or change the server's files. Although the code was thoroughly reviewed and tested, the verification located some heretofore unknown behavioral weaknesses. To verify this code, we invented new inference rules for reasoning about expressions with side effects, which occur often in C. We also formalized aspects of Unix file systems and processes, operating system and library calls, parts of the C language, and security properties. We propose an architecture for a software verification system which could be widely useful, and argue that our proof demonstrates that real world software written in real world languages can be verified.},
  author = {Black, Paul},
  file = {/home/uma/.zotero/data/storage/JZNUYJSH/Black - 1999 - Axiomatic Semantics Verification of a Secure Web S.pdf},
  month = jan,
  title = {Axiomatic {{Semantics Verification}} of a {{Secure Web Server}}},
  year = {1999}
}

@article{Bock2016,
  author = {Bock, Peter Brottveit and Bruni, Alessandro and Murawska, Agata and Sch{\"u}rmann, Carsten},
  journal = {Dale Miller's Festschrift},
  title = {Representing {{Session Types}}},
  year = {2016}
}

@inproceedings{Boutin1997,
  author = {Boutin, Samuel},
  booktitle = {International {{Symposium}} on {{Theoretical Aspects}} of {{Computer Software}}},
  pages = {515-529},
  publisher = {{Springer}},
  title = {Using {{Reflection}} to {{Build Efficient}} and {{Certified Decision Procedures}}},
  year = {1997}
}

@inproceedings{Bove2009,
  author = {Bove, Ana and Dybjer, Peter and Norell, Ulf},
  booktitle = {International {{Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  pages = {73-78},
  publisher = {{Springer}},
  title = {A {{Brief Overview}} of {{Agda}} \textendash{} a {{Functional Language}} with {{Dependent Types}}},
  year = {2009}
}

@inproceedings{Burstall1980,
  author = {Burstall, R. M. and MacQueen, D. B. and Sannella, D. T.},
  booktitle = {Proceedings of the 1980 {{ACM Conference}} on {{LISP}} and {{Functional Programming}}},
  doi = {10.1145/800087.802799},
  pages = {136-143},
  publisher = {{ACM}},
  series = {{{LFP}} '80},
  title = {{{HOPE}}: {{An Experimental Applicative Language}}},
  year = {1980}
}

@incollection{Caires2010,
  address = {{Berlin, Heidelberg}},
  author = {Caires, Lu{\'i}s and Pfenning, Frank},
  booktitle = {{{CONCUR}} 2010 - {{Concurrency Theory}}},
  doi = {10.1007/978-3-642-15375-4_16},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Gastin, Paul and Laroussinie, Fran{\c c}ois},
  file = {/home/uma/references/papers/Caires_Pfenning_2010_Session Types as Intuitionistic Linear Propositions.pdf},
  isbn = {978-3-642-15374-7 978-3-642-15375-4},
  language = {en},
  pages = {222-236},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Session {{Types}} as {{Intuitionistic Linear Propositions}}},
  volume = {6269},
  year = {2010}
}

@article{Carbone,
  author = {Carbone, Marco},
  file = {/home/uma/.zotero/data/storage/KZQLEKIG/Carbone - Mechanising your proofs in Coq.pdf},
  language = {en},
  pages = {16},
  title = {Mechanising Your Proofs in {{Coq}}}
}

@inproceedings{Casinghino2014,
  author = {Casinghino, Chris and Sj{\"o}berg, Vilhelm and Weirich, Stephanie},
  booktitle = {{{ACM SIGPLAN Notices}}},
  pages = {33-45},
  publisher = {{ACM}},
  title = {Combining {{Proofs}} and {{Programs}} in a {{Dependently Typed Language}}},
  volume = {49},
  year = {2014}
}

@techreport{Chaieb2003,
  author = {Chaieb, Amine and Nipkow, Tobias},
  institution = {{Technical report, Technische Universit{\"a}t M{\"u}nchen}},
  title = {Generic {{Proof Synthesis}} for {{Presburger Arithmetic}}},
  year = {2003}
}

@article{Chargueraud2012,
  abstract = {This paper provides an introduction to the locally nameless approach to the representation of syntax with variable binding, focusing in particular on the use of this technique in formal proofs. First, we explain the benefits of representing bound variables with de Bruijn indices while retaining names for free variables. Then, we explain how to describe and manipulate syntax in that form, and show how to define and reason about judgments on locally nameless terms.},
  author = {Chargu{\'e}raud, Arthur},
  doi = {10.1007/s10817-011-9225-2},
  file = {/home/uma/.zotero/data/storage/6RT2UBX4/Charguéraud - 2012 - The Locally Nameless Representation.pdf},
  issn = {0168-7433, 1573-0670},
  journal = {Journal of Automated Reasoning},
  keywords = {check},
  language = {en},
  month = oct,
  number = {3},
  pages = {363-408},
  title = {The {{Locally Nameless Representation}}},
  volume = {49},
  year = {2012}
}

@inproceedings{Chlipala2008,
  author = {Chlipala, Adam},
  booktitle = {{{ACM SIGPLAN Notices}}},
  doi = {10.1145/1411204.1411226},
  file = {/home/uma/references/papers/Chlipala_2008_Parametric Higher-Order Abstract Syntax for Mechanized Semantics.pdf},
  month = sep,
  pages = {143-156},
  title = {Parametric {{Higher}}-{{Order Abstract Syntax}} for {{Mechanized Semantics}}},
  volume = {43},
  year = {2008}
}

@article{Cooper1972,
  author = {Cooper, David C},
  journal = {Machine intelligence},
  number = {91-99},
  pages = {300},
  title = {Theorem {{Proving}} in {{Arithmetic}} without {{Multiplication}}},
  volume = {7},
  year = {1972}
}

@misc{CoqDeveloperCommunity,
  author = {{Coq Developer Community}},
  howpublished = {https://coq.inria.fr/},
  journal = {The Coq Proof Assistant},
  title = {The {{Coq Proof Assistant}}}
}

@article{Coquand1985,
  author = {Coquand, Thierry and Huet, G{\'e}rard},
  doi = {https://doi.org/10.1016/0890-5401(88)90005-3},
  file = {/home/uma/references/papers/Coquand_Huet_1985_The Calculus of Constructions.pdf},
  issn = {0890-5401},
  journal = {Information and Computation},
  number = {2},
  pages = {95-120},
  title = {The {{Calculus}} of {{Constructions}}},
  volume = {76},
  year = {1985}
}

@inproceedings{Coquand1990,
  author = {Coquand, Thierry and Paulin, Christine},
  booktitle = {{{COLOG}}-88},
  editor = {{Martin-L{\"o}f}, Per and Mints, Grigori},
  isbn = {978-3-540-46963-6},
  keywords = {Computation Rule,Elimination Rule,Inductive Type,Positive Operator,Type Theory},
  language = {en},
  pages = {50-66},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Inductively Defined Types},
  year = {1990}
}

@article{Curry1934,
  author = {Curry, Haskell B},
  journal = {Proceedings of the National Academy of Sciences},
  number = {11},
  pages = {584-590},
  title = {Functionality in {{Combinatory Logic}}},
  volume = {20},
  year = {1934}
}

@book{Curry1980,
  address = {{London ; New York}},
  editor = {Curry, Haskell B. and Hindley, J. Roger and Seldin, J. P.},
  isbn = {978-0-12-349050-6},
  keywords = {Curry; Haskell B,Haskell Brooks,Logic; Symbolic and mathematical},
  lccn = {QA9.2 .T6},
  publisher = {{Academic Press}},
  shorttitle = {To {{H}}.{{B}}. {{Curry}}},
  title = {To {{H}}.{{B}}. {{Curry}}: Essays on Combinatory Logic, Lambda Calculus, and Formalism},
  year = {1980}
}

@article{Dardha,
  author = {Dardha, Ornela},
  file = {/home/uma/.zotero/data/storage/J5EMGJS9/Dardha - Session Types in Coq.pdf},
  language = {en},
  pages = {28},
  title = {Session {{Types}} in {{Coq}}}
}

@inproceedings{Dardha2012,
  author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
  booktitle = {Principles and {{Practice}} of {{Declarative Programming}}, {{PPDP}}'12, {{Leuven}}, {{Belgium}} - {{September}} 19 - 21, 2012},
  doi = {10.1145/2370776.2370794},
  editor = {Schreye, Danny De and Janssens, Gerda and King, Andy},
  file = {/home/uma/references/papers/Dardha et al_2012_Session types revisited.pdf},
  isbn = {978-1-4503-1522-7},
  pages = {139--150},
  publisher = {{ACM}},
  title = {Session Types Revisited},
  year = {2012}
}

@incollection{Dardha2016,
  abstract = {In this chapter we introduce the encoding of session types into linear channel types and variant types and of session processes into standard \$\$\textbackslash{}pi \$\${$\pi$}-calculus processes.},
  author = {Dardha, Ornela},
  booktitle = {Type {{Systems}} for {{Distributed Programs}}: {{Components}} and {{Sessions}}},
  doi = {10.2991/978-94-6239-204-5_6},
  file = {/home/uma/references/papers/Dardha_2016_Session Types Revisited.pdf},
  isbn = {978-94-6239-203-8},
  month = jan,
  publisher = {{Springer}},
  title = {Session {{Types Revisited}}},
  year = {2016}
}

@incollection{Dardha2018,
  abstract = {The {$\pi$}-calculus, viewed as a core concurrent programming language, has been used as the target of much research on type systems for concurrency. In this paper we propose a new type system for deadlockfree session-typed {$\pi$}-calculus processes, by integrating two separate lines of work. The first is the propositions-as-types approach by Caires and Pfenning, which provides a linear logic foundation for session types and guarantees deadlock-freedom by forbidding cyclic process connections. The second is Kobayashi's approach in which types are annotated with priorities so that the type system can check whether or not processes contain genuine cyclic dependencies between communication operations. We combine these two techniques for the first time, and define a new and more expressive variant of classical linear logic with a proof assignment that gives a session type system with Kobayashi-style priorities. This can be seen in three ways: (i) as a new linear logic in which cyclic structures can be derived and a Cycle-elimination theorem generalises Cut-elimination; (ii) as a logically-based session type system, which is more expressive than Caires and Pfenning's; (iii) as a logical foundation for Kobayashi's system, bringing it into the sphere of the propositionsas-types paradigm.},
  address = {{Cham}},
  author = {Dardha, Ornela and Gay, Simon J.},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  doi = {10.1007/978-3-319-89366-2_5},
  editor = {Baier, Christel and Dal Lago, Ugo},
  file = {/home/uma/.zotero/data/storage/JSHNKASQ/Dardha and Gay - 2018 - A New Linear Logic for Deadlock-Free Session-Typed.pdf},
  isbn = {978-3-319-89365-5 978-3-319-89366-2},
  language = {en},
  pages = {91-109},
  publisher = {{Springer International Publishing}},
  title = {A {{New Linear Logic}} for {{Deadlock}}-{{Free Session}}-{{Typed Processes}}},
  volume = {10803},
  year = {2018}
}

@inproceedings{deBruijn1972,
  author = {{de Bruijn}, Nicolaas Govert},
  booktitle = {Indagationes {{Mathematicae}} ({{Proceedings}})},
  pages = {381-392},
  publisher = {{Elsevier}},
  title = {Lambda {{Calculus Notation}} with {{Nameless Dummies}}, a {{Tool}} for {{Automatic Formula Manipulation}}, with {{Application}} to the {{Church}}-{{Rosser Theorem}}},
  volume = {75},
  year = {1972}
}

@book{Despeyroux2000,
  abstract = {We present a formalization of a typed pi-calculus in the Calculus of Inductive Constructions. We give the rules for type-checking and for evaluation and formalize a proof of type preservation in the Coq system. The encoding of the pi-calculus in Coq uses Coq fonctions to represent bindings of variables. This kind of encoding is called a higher-order specication. It provides a concise description of the calculus, leading to simple proofs. The specification we propose for the pi-calculus formalizes communication by means of function application.},
  author = {Despeyroux, Jo{\"e}lle},
  file = {/home/uma/references/papers/Despeyroux_2000_A Higher-Order Specification of the π-Calculus.pdf;/home/uma/.zotero/data/storage/P2ZN3T47/summary.html},
  title = {A {{Higher}}-{{Order Specification}} of the {$\pi$}-{{Calculus}}},
  year = {2000}
}

@inproceedings{Dezani-Ciancaglini2008,
  author = {{Dezani-Ciancaglini}, Mariangiola and {de'Liguoro}, Ugo and Yoshida, Nobuko},
  booktitle = {Trustworthy {{Global Computing}}},
  editor = {Barthe, Gilles and Fournet, C{\'e}dric},
  isbn = {978-3-540-78663-4},
  pages = {257-275},
  publisher = {{Springer Berlin Heidelberg}},
  title = {On {{Progress}} for {{Structured Communications}}},
  year = {2008}
}

@inproceedings{Dezani-ciancaglini2010,
  author = {{Dezani-ciancaglini}, Mariangiola and De'Liguoro, Ugo},
  doi = {10.1007/978-3-642-14458-5_1},
  file = {/home/uma/references/papers/Dezani-ciancaglini_De'Liguoro_2010_Sessions and Session Types.pdf;/home/uma/references/papers/Dezani-ciancaglini_De'Liguoro_2010_Sessions and Session Types2.pdf},
  month = aug,
  pages = {1-28},
  title = {Sessions and {{Session Types}}: {{An Overview}}},
  year = {2010}
}

@phdthesis{Dilmore2019,
  author = {Dilmore, Eric},
  school = {School of Computing Science, University of Glasgow},
  title = {Pi-{{Calculus Session Types}} in {{Coq}}},
  type = {Master's {{Thesis}}},
  year = {2019}
}

@article{Dreyer2018,
  acmid = {3158154},
  articleno = {66},
  author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  doi = {10.1145/3158154},
  file = {/home/uma/references/papers/Jung et al_2017_RustBelt.pdf},
  issn = {2475-1421},
  issue_date = {January 2018},
  journal = {Proc. ACM Program. Lang.},
  keywords = {concurrency,logical relations,Rust,separation logic,type systems},
  location = {New York, NY, USA},
  month = dec,
  number = {POPL},
  numpages = {34},
  pages = {66:1-66:34},
  publisher = {{ACM}},
  title = {{{RustBelt}}: {{Securing}} the {{Foundations}} of the {{Rust Programming Language}}},
  volume = {2},
  year = {2017}
}

@article{Dybjer1994,
  abstract = {A general formulation of inductive and recursive definitions in Martin-L{\"o}f's type theory is presented. It extends Backhouse's `Do-It-Yourself Type Theory' to include inductive definitions of families of sets and definitions of functions by recursion on the way elements of such sets are generated. The formulation is in natural deduction and is intended to be a natural generalisation to type theory of Martin-L{\"o}f's theory of iterated inductive definitions in predicate logic.
Formal criteria are given for correct formation and introduction rules of a new set former capturing definition by strictly positive, iterated, generalised induction. Moreover, there is an inversion principle for deriving elimination and equality rules from the formation and introduction rules. Finally, there is an alternative schematic presentation of definition by recursion.
The resulting theory is a flexible and powerful language for programming and constructive mathematics. We hint at the wealth of possible applications by showing several basic examples: predicate logic, generalised induction, and a formalisation of the untyped lambda calculus.},
  author = {Dybjer, Peter},
  doi = {10.1007/BF01211308},
  file = {/home/uma/references/papers/Dybjer_1994_Inductive families.pdf},
  journal = {Formal Aspects of Computing},
  month = jan,
  pages = {440-465},
  title = {Inductive Families},
  volume = {6},
  year = {1994}
}

@article{Ferreira,
  author = {Ferreira, Francisco},
  file = {/home/uma/.zotero/data/storage/78VDBNRE/Ferreira - Adventures in Formalising the Meta-Theory of Sessi.pdf},
  keywords = {check},
  language = {en},
  pages = {27},
  title = {Adventures in {{Formalising}} the {{Meta}}-{{Theory}} of {{Session Types}}}
}

@techreport{Fischer1974,
  author = {Fischer, Michael J and Rabin, Michael O},
  institution = {{Massachusetts Inst of Tech Cambridge Project MAC}},
  title = {Super-{{Exponential Complexity}} of {{Presburger Arithmetic}}.},
  year = {1974}
}

@book{Gastin2010,
  address = {{Berlin}},
  author = {Gastin, Paul and {International Conference on Concurrency Theory}},
  isbn = {978-3-642-15374-7 978-3-642-15375-4},
  language = {English},
  note = {OCLC: 851074082},
  publisher = {{Springer}},
  shorttitle = {{{CONCUR}} 2010},
  title = {{{CONCUR}} 2010: Concurrency Theory : 21st International Conference : Proceedings},
  year = {2010}
}

@inproceedings{Gay2001,
  abstract = {We present a formalisation, in the theorem proving system Isabelle/HOL, of a linear type system for the pi calculus, including a proof of runtime safety of typed processes. The use of a uniform encoding of pi calculus syntax in a meta language, the development of a general theory of type environments, and the structured formalisation of the main proofs, facilitate the adaptation of the Isabelle theories and proof scripts to variations on the language and other type systems.},
  author = {Gay, Simon J.},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  editor = {Boulton, Richard J. and Jackson, Paul B.},
  file = {/home/uma/references/papers/Gay_2001_A Framework for the Formalisation of Pi Calculus Type Systems in Isabelle-HOL.pdf},
  isbn = {978-3-540-44755-9},
  keywords = {automatic theorem proving,pi calculus,semantics,Types},
  language = {en},
  pages = {217-232},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Framework}} for the {{Formalisation}} of {{Pi Calculus Type Systems}} in {{Isabelle}}/{{HOL}}},
  year = {2001}
}

@article{Gay2005,
  abstract = {Extending the pi calculus with the session types proposed by Honda et al. allows high-level specifications of structured patterns of communication, such as client-server protocols, to be expressed as types and verified by static typechecking. We define a notion of subtyping for session types, which allows protocol specifications to be extended in order to describe richer behaviour; for example, an implemented server can be refined without invalidating type-correctness of an overall system. We formalize the syntax, operational semantics and typing rules of an extended pi calculus, prove that typability guarantees absence of run-time communication errors, and show that the typing rules can be transformed into a practical typechecking algorithm.},
  author = {Gay, Simon and Hole, Malcolm},
  doi = {10.1007/s00236-005-0177-z},
  issn = {1432-0525},
  journal = {Acta Informatica},
  month = nov,
  number = {2},
  pages = {191-225},
  title = {Subtyping for {{Session Types}} in the {{Pi Calculus}}},
  volume = {42},
  year = {2005}
}

@article{Gay2008,
  author = {Gay, Simon},
  doi = {10.1017/S0960129508006944},
  file = {/home/uma/references/papers/Gay_2008_Bounded Polymorphism in Session Types.pdf},
  journal = {Mathematical Structures in Computer Science},
  month = oct,
  pages = {895-930},
  title = {Bounded {{Polymorphism}} in {{Session Types}}},
  volume = {18},
  year = {2008}
}

@article{Gay2010,
  abstract = {Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static type checking. Applications include network protocols, business processes, and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are four main contributions. First: an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second: we prove that the session type of a channel gives an upper bound on the necessary size of the buffer. Third: session types are manipulated by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Fourth: a notion of subtyping, including the standard subtyping relation for session types (imported into the functional setting), and a novel form of subtyping between standard and linear function types which allows the typechecker to handle linear types conveniently. Our new approach significantly simplifies session types in the functional setting, clarifies their essential features, and provides a secure foundation for language developments such as polymorphism and object-orientation.},
  author = {Gay, Simon J. and Vasconcelos, Vasco T.},
  doi = {10.1017/S0956796809990268},
  file = {/home/uma/.zotero/data/storage/ULZB8IH7/Gay and Vasconcelos - 2010 - Linear type theory for asynchronous session types.pdf},
  issn = {0956-7968, 1469-7653},
  journal = {Journal of Functional Programming},
  language = {en},
  month = jan,
  number = {1},
  pages = {19-50},
  title = {Linear Type Theory for Asynchronous Session Types},
  volume = {20},
  year = {2010}
}

@book{Girard1989,
  address = {{New York, NY, USA}},
  author = {Girard, Jean-Yves and Taylor, Paul and Lafont, Yves},
  file = {/home/uma/references/papers/Girard et al_1989_Proofs and Types.pdf},
  isbn = {0-521-37181-3},
  publisher = {{Cambridge University Press}},
  title = {Proofs and {{Types}}},
  year = {1989}
}

@article{Girard1992,
  abstract = {Usual typed lambda-calculi yield input/output specifications; in this paper the authors show how to extend this paradigm to complexity specifications. This is achieved by means of a restricted version of linear logic in which the use of exponential connectives is bounded in advance. This bounded linear logic naturally involves polynomials in its syntax and dynamics. It is then proved that any functional term of appropriate type actually encodes a polynomial-time algorithm and that conversely any polynomial-time function can be obtained in this way.},
  author = {Girard, Jean-Yves and Scedrov, Andre and Scott, Philip J.},
  doi = {10.1016/0304-3975(92)90386-T},
  file = {/home/uma/.zotero/data/storage/2C6DX6CM/Girard et al. - 1992 - Bounded linear logic a modular approach to polyno.pdf;/home/uma/.zotero/data/storage/T6A83EJ4/030439759290386T.html},
  issn = {0304-3975},
  journal = {Theoretical Computer Science},
  month = apr,
  number = {1},
  pages = {1-66},
  shorttitle = {Bounded Linear Logic},
  title = {Bounded Linear Logic: A Modular Approach to Polynomial-Time Computability},
  volume = {97},
  year = {1992}
}

@inproceedings{Giunti2010,
  abstract = {We present a reconstruction of session types in a conventional pi calculus where types are qualified as linear or unrestricted. Linearly typed communication channels are guaranteed to occur in exactly one thread, possibly multiple times. We equip types with a constructor that denotes the two ends of a same communication channel. In order to assess the flexibility of the new type system, we provide three distinct encodings (from the linear lambda calculus, from the linear pi calculus, and from the pi calculus with polarized variables) into our system. For each language we present operational and typing correspondences, showing that our system effectively subsumes the linear pi calculus as well as foregoing works on session types.},
  author = {Giunti, Marco and Vasconcelos, Vasco T.},
  booktitle = {{{CONCUR}} 2010 - {{Concurrency Theory}}},
  editor = {Gastin, Paul and Laroussinie, Fran{\c c}ois},
  isbn = {978-3-642-15375-4},
  pages = {432-446},
  publisher = {{Springer Berlin Heidelberg}},
  title = {A {{Linear Account}} of {{Session Types}} in the {{Pi Calculus}}},
  year = {2010}
}

@article{Goto2016,
  abstract = {Session types describe and constrain the input/output behaviour of systems. Existing session typing systems have limited support for polymorphism. For example, existing systems cannot provide the most general type for a generic proxy process that forwards messages between two channels. We provide a polymorphic session typing system for the {$\pi$} calculus, and demonstrate the utility of session-type-level functions in combination with polymorphic session typing. The type system guarantees subject reduction and safety properties, but not deadlock freedom. We describe a formalization of the type system in Coq. The proofs of subject reduction and safety properties, as well as typing of example processes, have been mechanically verified.},
  author = {Goto, Matthew and Jagadeesan, Radha and Jeffrey, Alan and Pitcher, Corin and Riely, James},
  doi = {10.1017/S0960129514000231},
  file = {/home/uma/.zotero/data/storage/E6TZEIHF/Goto et al. - 2016 - An extensible approach to session polymorphism.pdf},
  issn = {0960-1295, 1469-8072},
  journal = {Mathematical Structures in Computer Science},
  language = {en},
  month = mar,
  number = {3},
  pages = {465-509},
  title = {An Extensible Approach to Session Polymorphism},
  volume = {26},
  year = {2016}
}

@inproceedings{Gregoire2005,
  author = {Gr{\'e}goire, Benjamin and Mahboubi, Assia},
  booktitle = {International {{Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  pages = {98-113},
  publisher = {{Springer}},
  title = {Proving {{Equalities}} in a {{Commutative Ring Done Right}} in {{Coq}}},
  year = {2005}
}

@incollection{Griffith2013,
  abstract = {The Pi Calculus is a popular formalism for modeling distributed computation. Session Types extend the Pi Calculus with a static, inferable type system. Dependent Types allow for a more precise characterization of the behavior of programs, but in their full generality are not inferable. In this paper, we present LiquidPi an approach that combines the dependent type inferencing of Liquid Types with Honda's Session Types to give a more precise automatically derived description of the behavior of distributed programs. These types can be used to describe/enforce safety properties of distributed systems. We present a type system parametric over an underlying functional language with Pi Calculus connectives and give an inference algorithm for it by means of efficient external solvers and a set of dependent qualifier templates.},
  address = {{Berlin, Heidelberg}},
  author = {Griffith, Dennis and Gunter, Elsa L.},
  booktitle = {{{NASA Formal Methods}}},
  doi = {10.1007/978-3-642-38088-4_13},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Brat, Guillaume and Rungta, Neha and Venet, Arnaud},
  file = {/home/uma/references/papers/Griffith_Gunter_2013_LiquidPi.pdf},
  isbn = {978-3-642-38087-7 978-3-642-38088-4},
  language = {en},
  pages = {185-197},
  publisher = {{Springer Berlin Heidelberg}},
  shorttitle = {{{LiquidPi}}},
  title = {{{LiquidPi}}: {{Inferrable Dependent Session Types}}},
  volume = {7871},
  year = {2013}
}

@article{Harper,
  author = {Harper, Robert},
  file = {/home/uma/.zotero/data/storage/QP9DWQ84/Harper - Two Notions of Beauty in Programming.pdf},
  language = {en},
  pages = {108},
  title = {Two {{Notions}} of {{Beauty}} in {{Programming}}}
}

@book{Henry-Gerard1999,
  abstract = {This paper presents a method for coding pi-calculus in the COQ proof assistant, in order to use this environment to formalize properties of the pi-calculus. This method consists in making a syntactic discrimination between free names (then called parameters) and bound names (then called variables) of the processes, so that implicit renamings of bound names are avoided in the substitution operation. This technique has been used by J.McKinna and R.Pollack in an extensive study of PTS [5]. We use this coding here to prove subject reduction property for a type system of a monadic pi-calculus.},
  author = {{Henry-G{\'e}rard}, Lo{\"i}c and Meije, Projet},
  file = {/home/uma/references/papers/Henry-Gérard_Meije_1999_Proof of the subject reduction property for a π-calculus in COQ.pdf;/home/uma/.zotero/data/storage/FVFRE453/summary.html},
  title = {Proof of the Subject Reduction Property for a {$\pi$}-Calculus in {{COQ}}},
  year = {1999}
}

@article{Herbelin,
  author = {Herbelin, Hugo},
  file = {/home/uma/.zotero/data/storage/SCE3FQU9/Herbelin - The Calculus of Inductive Constructions.pdf},
  language = {en},
  pages = {24},
  title = {The {{Calculus}} of {{Inductive Constructions}}}
}

@inproceedings{Honda1993,
  abstract = {We formulate a typed formalism for concurrency where types denote freely composable structure of dyadic interaction in the symmetric scheme. The resulting calculus is a typed reconstruction of name passing process calculi. Systems with both the explicit and implicit typing disciplines, where types form a simple hierarchy of types, are presented, which are proved to be in accordance with each other. A typed variant of bisimilarity is formulated and it is shown that typed {$\beta$}-equality has a clean embedding in the bisimilarity. Name reference structure induced by the simple hierarchy of types is studied, which fully characterises the typable terms in the set of untyped terms. It turns out that the name reference structure results in the deadlock-free property for a subset of terms with a certain regular structure, showing behavioural significance of the simple type discipline.},
  author = {Honda, Kohei},
  booktitle = {{{CONCUR}}'93},
  editor = {Best, Eike},
  isbn = {978-3-540-47968-0},
  keywords = {Atomic Type,Constant Symbol,Dyadic Interaction,Functional Type,Reference Structure},
  language = {en},
  pages = {509-523},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Types for Dyadic Interaction},
  year = {1993}
}

@incollection{Honda1998,
  abstract = {We introduce basic language constructs and a type discipline as a foundation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous {$\pi$}-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the preceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline `a la ML, which offers a high-level type abstraction of interactive behaviours of programs as well as guaranteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are established. Implementation concerns are also addressed.},
  address = {{Berlin, Heidelberg}},
  author = {Honda, Kohei and Vasconcelos, Vasco T. and Kubo, Makoto},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  doi = {10.1007/BFb0053567},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Hankin, Chris},
  file = {/home/uma/.zotero/data/storage/FSEHSQGD/Honda et al. - 1998 - Language primitives and type discipline for struct.pdf},
  isbn = {978-3-540-64302-9 978-3-540-69722-0},
  language = {en},
  pages = {122-138},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Language Primitives and Type Discipline for Structured Communication-Based Programming},
  volume = {1381},
  year = {1998}
}

@inproceedings{Honda2008,
  author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
  booktitle = {Proceedings of the 35th {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  doi = {10.1145/1328438.1328472},
  file = {/home/uma/references/papers/Honda et al_2008_Multiparty Asynchronous Session Types.pdf},
  isbn = {978-1-59593-689-9},
  keywords = {causality,choreography,communications,mobile processes,multiparty,session types,structured programming},
  pages = {273-284},
  publisher = {{ACM}},
  series = {{{POPL}} '08},
  title = {Multiparty {{Asynchronous Session Types}}},
  year = {2008}
}

@article{Honsell2001,
  abstract = {We present a large and we think also significant case study in computer assisted formal reasoning. We start by giving a higher-order abstract syntax encoding of {$\pi$}-calculus in the higher-order inductive/coinductive-type theories CIC and CC(Co)Ind. This encoding gives rise to a full-fledged proof editor/proof assistant for the {$\pi$}-calculus, once we embed it in Coq, an interactive proof-development environment for CC(Co)Ind. Using this computerized assistant we prove formally a substantial chapter of the theory of strong late bisimilarity, which amounts essentially to Section 2 of A calculus of mobile processes by Milner, Parrow, and Walker. This task is greatly simplified by the use of higher-order syntax. In fact, not only we can delegate conveniently to the metalanguage {$\alpha$}-conversion and substitution, but, introducing a suitable axiomatization of the theory of contexts, we can accommodate also the machinery for generating new names. The axiomatization we introduce is quite general and should be easily portable to other formalizations based on higher-order syntax. The use of coinductive types and corresponding tactics allows to give alternative, and possibly more natural, proofs of many properties of strong late bisimilarity, w.r.t. those originally given by Milner, Parrow, and Walker.},
  author = {Honsell, Furio and Miculan, Marino and Scagnetto, Ivan},
  doi = {10.1016/S0304-3975(00)00095-5},
  file = {/home/uma/references/papers/Honsell et al_2001_π-calculus in (Co)inductive-type theory.pdf;/home/uma/.zotero/data/storage/KLRGFM2S/S0304397500000955.html},
  issn = {0304-3975},
  journal = {Theoretical Computer Science},
  keywords = {-calculus,Higher-order abstract syntax,Logical frameworks,Proof checking,Typed -calculus},
  month = feb,
  number = {2},
  pages = {239-285},
  series = {{{IC}}-{{EATCS}}'97},
  title = {{$\pi$}-Calculus in ({{Co}})Inductive-Type Theory},
  volume = {253},
  year = {2001}
}

@book{Howard1980,
  author = {Howard, William A},
  publisher = {{Academic Press}},
  title = {The {{Formulae}}-as-{{Types Notion}} of {{Construction}}. {{Hindley}}, {{JR}}, \& {{Seldin}}, {{JP}} ({{Eds}}), {{To HB Curry}}: {{Essays}} on {{Combinatory Logic}}, {{Lambda Calculus}} and {{Formalism}}},
  year = {1980}
}

@book{Janicic1997,
  author = {Jani{\v c}i{\'c}, Predrag and Green, Ian and Bundy, Alan},
  publisher = {{University of Edinburgh, Department of Artificial Intelligence}},
  title = {A {{Comparison}} of {{Decision Procedures}} in {{Presburger Arithmetic}}},
  year = {1997}
}

@article{Jensen,
  abstract = {This thesis investigates one possible way of proving functional correctness of distributed programs by integrating Session Types and Separation Logic. We introduce a language that has Session Type style typing judgements inside its Hoare triples and Separation Logic predicates inside its Session Type protocols. The language \textendash{} which builds on an existing Java-like language built by Bengtson et al. [3] \textendash{} is implemented in Coq, which has also been used to prove properties and theorems of the language semantics. The extended language has the new send, recv and start primitives with which programs with multiple processes that communicate using message-passing governed by Session Type protocols can be constructed. Using Separation Logic predicates instead of types to describe the transferred data, receivers are allowed to assume properties proven by the sending party.},
  author = {Jensen, Morten Fangel},
  file = {/home/uma/references/papers/Jensen_Formal Veriﬁcation of Distributed Programs using Session Types and Coq.pdf},
  language = {en},
  pages = {74},
  title = {Formal {{Verification}} of {{Distributed Programs}} Using {{Session Types}} and {{Coq}}}
}

@article{Jia,
  abstract = {Session types provide a means to prescribe the communication behavior between concurrent message-passing processes. However, in a distributed setting, some processes may be written in languages that do not support static typing of sessions or may be compromised by a malicious intruder, violating invariants of the session types. In such a setting, dynamically monitoring communication between processes becomes a necessity for identifying undesirable actions. In this paper, we show how to dynamically monitor communication to enforce adherence to session types in a higher-order setting. We present a system of blame assignment in the case when the monitor detects an undesirable action and an alarm is raised. We prove that dynamic monitoring does not change system behavior for welltyped processes, and that one of an indicated set of possible culprits must have been compromised in case of an alarm.},
  author = {Jia, Limin and Gommerstadt, Hannah and Pfenning, Frank},
  file = {/home/uma/references/papers/Jia et al_Monitors and Blame Assignment for Higher-Order Session Types.pdf},
  language = {en},
  pages = {42},
  title = {Monitors and {{Blame Assignment}} for {{Higher}}-{{Order Session Types}}}
}

@book{Kobayashi1996,
  abstract = {The economy and flexibility of the pi-calculus make it attractive both as an object of theoretical study and as a basis for concurrent language design and implementation. However, such generality has a cost: encoding higher-level features like functional computation in pi-calculus throws away potentially useful information. We show how a linear type system can be used to recover important static information about a process's behaviour. In particular, we can guarantee that two processes communicating over a linear channel cannot interfere with other communicating processes. This enables more aggressive optimisation of communications over linear channels and allows useful refinements to the usual notions of process equivalence for pi-calculus. After},
  author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
  file = {/home/uma/references/papers/Kobayashi et al_1996_Linearity and the Pi-Calculus.pdf;/home/uma/.zotero/data/storage/7QEAP97G/summary.html},
  title = {Linearity and the {{Pi}}-{{Calculus}}},
  year = {1996}
}

@article{Kobayashi1999,
  author = {Kobayashi, Naoki and Pierce, Benjamin and N. Turner, David},
  doi = {10.1145/330249.330251},
  file = {/home/uma/references/papers/Kobayashi et al_1999_Linearity and the Pi-Calculus.pdf},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  month = dec,
  pages = {914-947},
  title = {Linearity and the {{Pi}}-{{Calculus}}},
  volume = {21},
  year = {1999}
}

@article{Kobayashi2002,
  author = {Kobayashi, Naoki},
  doi = {10.1006/inco.2002.3171},
  journal = {Information and Computation},
  month = sep,
  pages = {122-159},
  title = {A {{Type System}} for {{Lock}}-{{Free Processes}}},
  volume = {177},
  year = {2002}
}

@incollection{Kobayashi2003,
  address = {{Berlin, Heidelberg}},
  author = {Kobayashi, Naoki},
  booktitle = {Formal {{Methods}} at the {{Crossroads}}. {{From Panacea}} to {{Foundational Support}}},
  doi = {10.1007/978-3-540-40007-3_26},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Aichernig, Bernhard K. and Maibaum, Tom},
  file = {/home/uma/.zotero/data/storage/JX4NCLRW/Kobayashi - 2003 - Type Systems for Concurrent Programs.pdf},
  isbn = {978-3-540-20527-2 978-3-540-40007-3},
  language = {en},
  pages = {439-453},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Type {{Systems}} for {{Concurrent Programs}}},
  volume = {2757},
  year = {2003}
}

@incollection{Kobayashi2003a,
  address = {{Berlin, Heidelberg}},
  author = {Kobayashi, Naoki},
  booktitle = {Formal {{Methods}} at the {{Crossroads}}. {{From Panacea}} to {{Foundational Support}}},
  doi = {10.1007/978-3-540-40007-3_26},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Aichernig, Bernhard K. and Maibaum, Tom},
  isbn = {978-3-540-20527-2 978-3-540-40007-3},
  language = {en},
  pages = {439-453},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Type {{Systems}} for {{Concurrent Programs}}},
  volume = {2757},
  year = {2003}
}

@inproceedings{Kobayashi2006,
  abstract = {We extend a previous type system for the {$\pi$}-calculus that guarantees deadlock-freedom. The previous type systems for deadlock- freedom either lacked a reasonable type inference algorithm or were not strong enough to ensure deadlock-freedom of processes using recursion. Although the extension is fairly simple, the new type system admits type inference and is much more expressive than the previous type systems that admit type inference. In fact, we show that the simply-typed {$\lambda$}- calculus with recursion can be encoded into the deadlock-free fragment of our typed {$\pi$}-calculus. To enable analysis of realistic programs, we also present an extension of the type system to handle recursive data structures like lists. Both extensions have already been incorporated into the recent release of TyPiCal, a type-based analyzer for the {$\pi$}-calculus.},
  author = {Kobayashi, Naoki},
  doi = {10.1007/11817949_16},
  file = {/home/uma/.zotero/data/storage/BDGUANKY/Kobayashi - 2006 - A New Type System for Deadlock-Free Processes.pdf},
  month = jan,
  pages = {233-247},
  title = {A {{New Type System}} for {{Deadlock}}-{{Free Processes}}},
  year = {2006}
}

@techreport{Kobayashi2007,
  author = {Kobayashi, Naoki},
  institution = {{Tohoku University}},
  note = {Extended version of Kobayashi 2003},
  title = {Type Systems for Concurrent Programs},
  year = {2007}
}

@inproceedings{Kokke2015,
  author = {Kokke, Wen and Swierstra, Wouter},
  booktitle = {International {{Conference}} on {{Mathematics}} of {{Program Construction}}},
  pages = {276-301},
  publisher = {{Springer}},
  title = {Auto in {{Agda}}},
  year = {2015}
}

@incollection{Koomen1991,
  abstract = {The Calculus of Communicating Systems (CCS) originates from Robin Milner. CCS deals with communication behaviours of (non-deterministic) finite state machines. Among the first publications on CCS is [Mil78]. In 1980, Milner published his first book on CCS [Mil80]; [Mil89] is an update of the previous book with many new results. The calculus is meant as a formal mathematical framework which can be used to specify communicating systems and to verify properties of them. A system is considered to consist of parts, each of which has an own identity, which persists through time. A system will be characterized by the actions it can perform.},
  address = {{Boston, MA}},
  author = {Koomen, C. J.},
  booktitle = {The {{Design}} of {{Communicating Systems}}: {{A System Engineering Approach}}},
  doi = {10.1007/978-1-4615-4020-5_2},
  editor = {Koomen, C. J.},
  isbn = {978-1-4615-4020-5},
  keywords = {Behaviour Equation,Input Port,Normal Form,Output Port,State Graph},
  language = {en},
  pages = {11-26},
  publisher = {{Springer US}},
  series = {The {{Springer International Series}} in {{Engineering}} and {{Computer Science}}},
  title = {Calculus of {{Communicating Systems}}},
  year = {1991}
}

@article{Krishnaswami2015,
  author = {R. Krishnaswami, Neelakantan and Pradic, Pierre and Benton, Nick},
  doi = {10.1145/2676726.2676969},
  journal = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
  month = jan,
  pages = {17-30},
  title = {Integrating {{Dependent}} and {{Linear Types}}},
  volume = {2015},
  year = {2015}
}

@article{Lindley,
  abstract = {Row types provide an account of extensibility that combines well with parametric polymorphism and type inference. We discuss the integration of row types and session types in a concurrent functional programming language, and how row types can be used to describe extensibility in session-typed communication.},
  author = {Lindley, Sam and Morris, J Garrett},
  file = {/home/uma/.zotero/data/storage/YT6IF428/Lindley and Morris - Lightweight Functional Session Types.pdf},
  language = {en},
  pages = {20},
  title = {Lightweight {{Functional Session Types}}}
}

@inproceedings{Lindley2015,
  abstract = {Session types provide a static guarantee that concurrent programs respect communication protocols. Recently, Caires, Pfenning, and Toninho, and Wadler, have developed a correspondence between propositions of linear logic and session typed {$\pi$}-calculus processes. We relate the cut-elimination semantics of this approach to an operational semantics for session-typed concurrency in a functional language. We begin by presenting a variant of Wadler's session-typed core functional language, GV. We give a small-step operational semantics for GV. We develop a suitable notion of deadlock, based on existing approaches for capturing deadlock in {$\pi$}-calculus, and show that all well-typed GV programs are deadlock-free, deterministic, and terminating. We relate GV to linear logic by giving translations between GV and CP, a process calculus with a type system and semantics based on classical linear logic. We prove that both directions of our translation preserve reduction; previous translations from GV to CP, in contrast, failed to preserve {$\beta$}-reduction. Furthermore, to demonstrate the modularity of our approach, we define two extensions of GV which preserve deadlock-freedom, determinism, and termination.},
  author = {Lindley, Sam and Morris, J. Garrett},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  editor = {Vitek, Jan},
  file = {/home/uma/.zotero/data/storage/ZDXAZDMH/Lindley and Morris - 2015 - A Semantics for Propositions as Sessions.pdf},
  isbn = {978-3-662-46669-8},
  keywords = {Closed Channel,Functional Language,Linear Logic,Reduction Rule,Typing Rule},
  language = {en},
  pages = {560-584},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Semantics}} for {{Propositions}} as {{Sessions}}},
  year = {2015}
}

@inproceedings{Lindley2016,
  abstract = {We present a novel embedding of session-typed concurrency in Haskell. We extend an existing HOAS embedding of linear {$\lambda$}-calculus with a set of core session-typed primitives, using indexed type families to express the constraints of the session typing discipline. We give two interpretations of our embedding, one in terms of GHC's built-in concurrency and another in terms of purely functional continuations. Our safety guarantees, including deadlock freedom, are assured statically and introduce no additional runtime overhead.},
  address = {{New York, NY, USA}},
  author = {Lindley, Sam and Morris, J. Garrett},
  booktitle = {Proceedings of the 9th {{International Symposium}} on {{Haskell}}},
  doi = {10.1145/2976002.2976018},
  file = {/home/uma/references/papers/Lindley_Morris_2016_Embedding Session Types in Haskell.pdf},
  isbn = {978-1-4503-4434-0},
  keywords = {check,embedded languages,linear types,session types},
  pages = {133--145},
  publisher = {{ACM}},
  series = {Haskell 2016},
  title = {Embedding {{Session Types}} in {{Haskell}}},
  year = {2016}
}

@article{Martin2000,
  author = {Martin, Robert Cecil},
  journal = {Object Mentor},
  number = {34},
  pages = {597},
  title = {Design {{Principles}} and {{Design Patterns}}},
  volume = {1},
  year = {2000}
}

@article{McBride2000,
  author = {McBride, Conor},
  title = {Dependently {{Typed Functional Programs}} and {{Their Proofs}}},
  year = {2000}
}

@article{McBride2004,
  author = {McBride, Conor and McKinna, James},
  journal = {Journal of functional programming},
  number = {1},
  pages = {69-111},
  title = {The {{View}} from the {{Left}}},
  volume = {14},
  year = {2004}
}

@incollection{McBride2016,
  abstract = {Work to date on combining linear types and dependent types has deliberately and successfully avoided doing so. Entirely fit for their own purposes, such systems wisely insist that types depend only on the replicable sublanguage, thus sidestepping the issue of counting uses of limited-use data either within types or in ways which are only really needed to shut the typechecker up. As a result, the linear implication (`lollipop') stubbornly remains a non-dependent \$\$S \textbackslash{}backslashmultimap T\$\$S{$\multimap$}T. This paper defines and establishes the basic metatheory of a type theory supporting a `dependent lollipop' \$\$(x\textbackslash{}backslash!:\textbackslash{}backslash!S)\textbackslash{}backslashmultimap T[x]\$\$(x:S){$\multimap$}T[x], where what the input used to be is in some way commemorated by the type of the output. For example, we might convert list to length-indexed vectors in place by a function with type \$\$(l\textbackslash{}backslash!:\textbackslash{}backslash!\textbackslash{}backslashmathsf \{List\}\textbackslash{}backslash,X)\textbackslash{}backslashmultimap \textbackslash{}backslashmathsf \{Vector\}\textbackslash{}backslash,X\textbackslash{}backslash,(\textbackslash{}backslashmathsf \{length\}\textbackslash{}backslash,l)\$\$(l:ListX){$\multimap$}VectorX(lengthl). Usage is tracked with resource annotations belonging to an arbitrary rig, or `riNg without Negation'. The key insight is to use the rig's zero to mark information in contexts which is present for purposes of contemplation rather than consumption, like a meal we remember fondly but cannot eat twice. We need no runtime copies of l to form the above vector type. We can have plenty of nothing with no additional runtime resource, and nothing is plenty for the construction of dependent types.},
  address = {{Cham}},
  author = {McBride, Conor},
  booktitle = {A {{List}} of {{Successes That Can Change}} the {{World}}: {{Essays Dedicated}} to {{Philip Wadler}} on the {{Occasion}} of {{His}} 60th {{Birthday}}},
  doi = {10.1007/978-3-319-30936-1_12},
  editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
  file = {/home/uma/references/papers/McBride_2016_I Got Plenty o' Nuttin'.pdf},
  isbn = {978-3-319-30936-1},
  pages = {207-233},
  publisher = {{Springer International Publishing}},
  title = {I {{Got Plenty}} o' {{Nuttin}}'},
  year = {2016}
}

@book{Milner1980,
  abstract = {A Calculus of Communicating Systems...},
  address = {{Berlin Heidelberg}},
  author = {Milner, R.},
  file = {/home/uma/.zotero/data/storage/NF8LPBSP/9783540102359.html},
  isbn = {978-3-540-10235-9},
  language = {en},
  publisher = {{Springer-Verlag}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Calculus}} of {{Communicating Systems}}},
  year = {1980}
}

@book{Milner1982,
  author = {Milner, R.},
  isbn = {978-0-387-10235-1},
  month = jan,
  publisher = {{Springer-Verlag}},
  title = {A {{Calculus}} of {{Communicating Systems}}},
  year = {1982}
}

@book{Milner1989,
  author = {Milner, R.},
  isbn = {978-0-13-114984-7},
  month = jan,
  publisher = {{Prentice-Hall, Inc.}},
  title = {Communication and {{Concurrency}}},
  year = {1989}
}

@inproceedings{Milner1991,
  author = {Milner, Robin},
  booktitle = {Handbook of Theoretical Computer Science (Vol. {{B}})},
  isbn = {978-0-444-88074-1},
  month = feb,
  pages = {1201-1242},
  publisher = {{MIT Press}},
  title = {Operational and Algebraic Semantics of Concurrent Processes},
  year = {1991}
}

@article{Morris2016,
  author = {Morris, J. Garrett and Morris, J. Garrett},
  doi = {10.1145/2951913.2951925},
  file = {/home/uma/references/papers/Morris_Morris_2016_The best of both worlds.pdf},
  issn = {0362-1340},
  journal = {ACM SIGPLAN Notices},
  month = apr,
  number = {9},
  pages = {448-461},
  shorttitle = {The Best of Both Worlds},
  title = {The Best of Both Worlds: Linear Functional Programming without Compromise},
  volume = {51},
  year = {2016}
}

@inproceedings{Mostrous2007,
  abstract = {Abstract. This paper proposes two typing systems for session interactions in higherorder mobile processes. Session types for the HO{$\pi$}-calculus capture high-level structures of communication protocols and code mobility as type abstraction, and can be used to statically check the safe and consistent process composition in communication-centric distributed software. Integration of arbitrary higher-order code mobility and sessions leads to technical difficulties in type soundness, because linear usage of session channels and completion of sessions are required in executed code. By using techniques from the linear {$\lambda$}-calculus, we develop a coherent and tractable session typing system for the HO{$\pi$}-calculus. We also present an alternative system based on fine-grained process types. The formal comparison between the two systems offers insight on the interplay between higher-order code mobility and session types. 1},
  author = {Mostrous, Dimitris and Yoshida, Nobuko},
  booktitle = {In {{TLCA}}'07, {{LNCS}}},
  file = {/home/uma/references/papers/Mostrous_Yoshida_2007_Two session typing systems for higher-order mobile processes.pdf;/home/uma/.zotero/data/storage/6M5A559Q/summary.html},
  pages = {321--335},
  publisher = {{Springer-Verlag}},
  title = {Two Session Typing Systems for Higher-Order Mobile Processes},
  year = {2007}
}

@inproceedings{Mostrous2009,
  author = {Mostrous, Dimitris and Yoshida, Nobuko and Honda, Kohei},
  doi = {10.1007/978-3-642-00590-9_23},
  file = {/home/uma/references/papers/Mostrous et al_2009_Global Principal Typing in Partially Commutative Asynchronous Sessions.pdf},
  month = aug,
  pages = {316-332},
  title = {Global {{Principal Typing}} in {{Partially Commutative Asynchronous Sessions}}},
  year = {2009}
}

@inproceedings{NeilD.Jones2004,
  booktitle = {Proceedings of the 31st {{ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}, {{POPL}} 2004, {{Venice}}, {{Italy}}, {{January}} 14-16, 2004},
  doi = {10.1145/964001.964011},
  editor = {{Neil D. Jones} and Leroy, Xavier},
  pages = {111-122},
  publisher = {{ACM}},
  title = {Parsing {{Expression Grammars}}: {{A Recognition}}-{{Based Syntactic Foundation}}},
  year = {2004}
}

@inproceedings{Norell2009,
  author = {Norell, Ulf and Chapman, James},
  booktitle = {Advanced {{Functional Programming}}. {{LNCS}} 5832},
  pages = {230-266},
  publisher = {{Springer}},
  title = {Dependently {{Typed Programming}} in {{Agda}}},
  year = {2009}
}

@inproceedings{Norrish2003,
  author = {Norrish, Michael},
  booktitle = {International {{Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  pages = {71-86},
  publisher = {{Springer}},
  title = {Complete {{Integer Decision Procedures}} as {{Derived Rules}} in {{HOL}}},
  year = {2003}
}

@book{Norrish2006,
  author = {Norrish, Michael},
  title = {Deciding {{Presburger Arithmetic}}},
  year = {2006}
}

@article{Orchard,
  abstract = {DOMINIC ORCHARD, University of Kent, UK VILEM-BENJAMIN LIEPELT, University of Kent, UK HARLEY EADES III, Augusta University, USA In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples. CCS Concepts: \textbullet{} Theory of computation \textrightarrow Modal and temporal logics; Program specifications; Program verification; Linear logic; Type theory.},
  author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Iii, Harley Eades},
  file = {/home/uma/.zotero/data/storage/GQM74RPQ/Orchard et al. - Quantitative Program Reasoning with Graded Modal T.pdf},
  language = {en},
  pages = {30},
  title = {Quantitative {{Program Reasoning}} with {{Graded Modal Types}}},
  volume = {3}
}

@article{Oury2008,
  author = {Oury, Nicolas and Swierstra, Wouter},
  journal = {ACM Sigplan Notices},
  number = {9},
  pages = {39-50},
  title = {The {{Power}} of {{Pi}}},
  volume = {43},
  year = {2008}
}

@article{Paykin2017,
  author = {Paykin, Jennifer and Zdancewic, S},
  doi = {10.1145/3156695.3122965},
  file = {/home/uma/references/papers/Paykin_Zdancewic_2017_The Linearity Monad.pdf},
  journal = {ACM SIGPLAN Notices},
  month = sep,
  pages = {117-132},
  title = {The {{Linearity Monad}}},
  volume = {52},
  year = {2017}
}

@article{Petz,
  author = {Petz, Adam},
  file = {/home/uma/.zotero/data/storage/6SG39KD6/Petz - A Semantics for Attestation Protocols using Sessio.pdf},
  language = {en},
  pages = {61},
  title = {A {{Semantics}} for {{Attestation Protocols}} Using {{Session Types}} in {{Coq}}}
}

@book{Pierce2002,
  author = {Pierce, Benjamin C.},
  isbn = {978-0-262-16209-8},
  publisher = {{MIT Press}},
  title = {Types and {{Programming Languages}}},
  year = {2002}
}

@article{Power2000,
  author = {Power, James and Webster, Caroline},
  file = {/home/uma/references/papers/Power_Webster_2000_Working with Linear Logic in Coq.pdf},
  month = jul,
  title = {Working with {{Linear Logic}} in {{Coq}}},
  year = {2000}
}

@inproceedings{Presburger1929,
  author = {Presburger, Mojzesz},
  booktitle = {Comptes-{{Rendus Du Ler Congres Des Mathematiciens Des Pays Slavs}}},
  title = {Uber {{Die Vollstandigkeiteines Gewissen Systems Der Arithmetik Ganzer Zahlen}}, in {{Welchen Die Addition Als Einzige Operation Hervortritt}}},
  year = {1929}
}

@inproceedings{Pugh1991,
  author = {Pugh, William},
  booktitle = {Proceedings of the 1991 {{ACM}}/{{IEEE Conference}} on {{Supercomputing}}},
  pages = {4-13},
  publisher = {{ACM}},
  title = {The {{Omega Test}}: {{A Fast}} and {{Practical Integer Programming Algorithm}} for {{Dependence Analysis}}},
  year = {1991}
}

@book{Russinoff2017,
  author = {Russinoff, David M},
  title = {Polynomial {{Terms}} and {{Sparse Horner Normal Form}}},
  year = {2017}
}

@inproceedings{Sadrzadeh2003,
  author = {Sadrzadeh, Mehrnoosh},
  booktitle = {In {{Emerging Trends TPHOLS}} '03},
  file = {/home/uma/references/papers/Sadrzadeh_2003_Modal Linear Logic in Higher Order Logic.pdf},
  keywords = {rank3},
  pages = {75-93},
  title = {Modal {{Linear Logic}} in {{Higher Order Logic}}: {{An Experiment}} with {{Coq}}},
  year = {2003}
}

@book{Sangiorgi2001,
  abstract = {From the Publisher:Mobile systems, whose components communicate and change their structure, now pervade the informational world and the wider world of which it is a part. The science of mobile systems is as yet immature, however. This book presents the pi-calculus, a theory of mobile systems. The pi-calculus provides a conceptual framework for understanding mobility, and mathematical tools for expressing systems and reasoning about their behaviors.
The book serves both as a reference for the theory and as an extended demonstration of how to use pi-calculus to describe systems and analyze their properties. It covers the basic theory of pi-calculus, typed pi-calculi, higher-order processes, the relationship between pi-calculus and lambda-calculus, and applications of pi-calculus to object-oriented design and programming.
The book is written at the graduate level, assuming no prior acquaintance with the subject, and is intended for computer scientists interested in mobile systems.},
  address = {{New York, NY, USA}},
  author = {Sangiorgi, Davide and Walker, David},
  isbn = {978-0-521-78177-0},
  publisher = {{Cambridge University Press}},
  shorttitle = {{{PI}}-{{Calculus}}},
  title = {{{PI}}-{{Calculus}}: {{A Theory}} of {{Mobile Processes}}},
  year = {2001}
}

@article{Scagnetto,
  author = {Scagnetto, Ivan},
  file = {/home/uma/.zotero/data/storage/EQX65FWZ/Scagnetto - A Theory of Contexts for Higher-Order Encodings  o.pdf},
  language = {en},
  pages = {29},
  title = {A {{Theory}} of {{Contexts}} for {{Higher}}-{{Order Encodings}}  of {{Process Algebras}}}
}

@inproceedings{Schack-Nielsen2008,
  __markedentry = {[uma:]},
  abstract = {CLF (Concurrent LF) [CPWW02a] is a logical framework for specifying and implementing deductive and concurrent systems from areas, such as programming language theory, security protocol analysis, process algebras, and logics. Celf is an implementation of the CLF type theory that extends the LF type theory by linear types to support representation of state and a monad to support representation of concurrency. It relies on the judgments-as-types methodology for specification and the interpretation of CLF signatures as concurrent logic programs [LPPW05] for experimentation. Celf is written in Standard ML and compiles with MLton, MLKit, and SML/NJ. The source code and a collection of examples are available from http://www.twelf.org/\textasciitilde{}celf.},
  author = {{Schack-Nielsen}, Anders and Sch{\"u}rmann, Carsten},
  booktitle = {Automated {{Reasoning}}},
  editor = {Armando, Alessandro and Baumgartner, Peter and Dowek, Gilles},
  isbn = {978-3-540-71070-7},
  pages = {320-326},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Celf -- {{A Logical Framework}} for {{Deductive}} and {{Concurrent Systems}} ({{System Description}})},
  year = {2008}
}

@incollection{Sestoft2017,
  abstract = {This chapter introduces the approach taken and the plan followed in this book. We show how to represent arithmetic expressions and other program fragments as data structures in F\# as well as Java, and how to compute with such program fragments. We also introduce various basic concepts of programming languages.},
  address = {{Cham}},
  author = {Sestoft, Peter},
  booktitle = {Programming {{Language Concepts}}},
  doi = {10.1007/978-3-319-60789-4},
  isbn = {978-3-319-60789-4},
  pages = {1-12},
  publisher = {{Springer International Publishing}},
  title = {Programming {{Language Concepts}}},
  year = {2017}
}

@book{Sorensen2006,
  author = {S{\o}rensen, Morten Heine and Urzyczyn, Pawe\textbackslash{}l},
  publisher = {{Elsevier Science Limited}},
  title = {Lectures on the {{Curry}}-{{Howard Isomorphism}} ({{Studies}} in {{Logic}} and the {{Foundations}} of {{Mathematics}}, 0049-{{237X}}; v. 149)},
  year = {2006}
}

@techreport{Stansifer1984,
  author = {Stansifer, Ryan},
  institution = {{Cornell University}},
  title = {Presburger's {{Article}} on {{Integer Arithmetic}}: {{Remarks}} and {{Translation}}},
  year = {1984}
}

@inproceedings{Steele1994,
  author = {Steele, Guy L. and {Jr.}},
  booktitle = {In 21st {{Annual ACM Symposium}} on {{Principles}} of {{Programming Languages}} ({{POPL}}'94},
  pages = {472-492},
  publisher = {{ACM Press}},
  title = {Building {{Interpreters}} by {{Composing Monads}}},
  year = {1994}
}

@inproceedings{Takeuchi1994,
  abstract = {We present a small language \$\$\textbackslash{}backslashmathcal\{L\}\$\$and its typing system, starting from the idea of interaction, one of the important notions in parallel and distributed computing. \$\$\textbackslash{}backslashmathcal\{L\}\$\$is based on, apart from such constructs as parallel composition and process creation, three pairs of communication primitives which use the notion of a session, a semantically atomic chain of communication actions which can interleave with other such chains freely, for high-level abstraction of interactionbased computing. The three primitives enable programmers to elegantly describe complex interactions among processes with a rigorous type discipline similar to ML [4]. The language is given formal operational semantics and a type inference system, regarding which we prove that if a program is well-typed in the typing system, it never causes run-time error due to type inconsistent communication patterns, offering a new foundation for type discipline in parallel programming languages.},
  author = {Takeuchi, Kaku and Honda, Kohei and Kubo, Makoto},
  booktitle = {{{PARLE}}'94 {{Parallel Architectures}} and {{Languages Europe}}},
  editor = {Halatsis, Costas and Maritsas, Dimitrios and Philokyprou, George and Theodoridis, Sergios},
  isbn = {978-3-540-48477-6},
  pages = {398-413},
  publisher = {{Springer Berlin Heidelberg}},
  title = {An {{Interaction}}-{{Based Language}} and {{Its Typing System}}},
  year = {1994}
}

@article{Thiemann,
  abstract = {Session types describe structured communication on heterogeneously typed channels at a high level. Their tail-recursive structure imposes a protocol that can be described by a regular language. The types of transmitted values are drawn from the underlying functional language, abstracting from the details of serializing values of structured data types.},
  author = {Thiemann, Peter and Vasconcelos, Vasco T},
  file = {/home/uma/references/papers/Thiemann_Vasconcelos_Context-Free Session Types.pdf},
  language = {en},
  pages = {14},
  title = {Context-{{Free Session Types}}}
}

@inproceedings{Thiemann2014,
  abstract = {Session types enable fine-grained static control over communication protocols. Gradual typing is a means to safely integrate statically and dynamically typed program fragments.
We propose a calculus for synchronous functional two-party session types, augment this calculus with a dynamically typed fragment as well as coercion operations between statically and dynamically typed parts, and establish its basic metatheory: type preservation and progress. A technical novelty is the notion of coercions for the choice operator in session types which is related to coercions of sum types.},
  author = {Thiemann, Peter},
  doi = {10.1007/978-3-662-45917-1_10},
  file = {/home/uma/references/papers/Thiemann_2014_Session Types with Gradual Typing.pdf},
  month = sep,
  pages = {144-158},
  title = {Session {{Types}} with {{Gradual Typing}}},
  volume = {8902},
  year = {2014}
}

@inproceedings{Thiemann2017,
  abstract = {We propose an extension of binary session types with interleaved sessions that work similar to interrupts. The participants in a session register a set of trigger predicates that are associated with local protocols. When a trigger fires, all participants switch simultaneously to the interleaved protocol and return to the original protocol afterwards. The use of interleaved sessions enables the elegant specification of protocols that are otherwise cumbersome to specify.},
  author = {Thiemann, Peter},
  doi = {10.1145/3019612.3019804},
  month = apr,
  pages = {1312-1318},
  title = {Interleaving Sessions with Predicates},
  year = {2017}
}

@inproceedings{Toninho2011,
  author = {Toninho, Bernardo and Caires, Lu{\'i}s and Pfenning, Frank},
  booktitle = {Proceedings of the 13th {{International ACM SIGPLAN Symposium}} on {{Principles}} and {{Practices}} of {{Declarative Programming}}},
  doi = {10.1145/2003476.2003499},
  isbn = {978-1-4503-0776-5},
  keywords = {process calculus,type theory},
  pages = {161-172},
  publisher = {{ACM}},
  series = {{{PPDP}} '11},
  title = {Dependent {{Session Types}} via {{Intuitionistic Linear Type Theory}}},
  year = {2011}
}

@inproceedings{vanderWalt2012,
  author = {{van der Walt}, Paul and Swierstra, Wouter},
  booktitle = {Symposium on {{Implementation}} and {{Application}} of {{Functional Languages}}},
  pages = {157-173},
  publisher = {{Springer}},
  title = {Engineering {{Proof}} by {{Reflection}} in {{Agda}}},
  year = {2012}
}

@phdthesis{vanderWalt2012a,
  author = {{van der Walt}, PD},
  title = {Reflection in {{Agda}}},
  type = {Master's {{Thesis}}},
  year = {2012}
}

@inproceedings{Vasconcelos1992,
  abstract = {The present report introduces a typing system for a version of Milner's polyadic  {\ss}-calculus, and a typing inference algorithm. The central concept underlying the typing system is the notion of type assignment, where each free name in a term is assigned a type, the term itself being given multiple name-type pairs. This observation leads to a clean typing system for Milner's sorting, and induces an efficient algorithm to infer the typing of a term. The typing system enjoys a subject-reduction property and possesses a notion of principal typing-scheme. Furthermore, the algorithm to reconstruct the principal typing-scheme of a process, or to detect its inexistence, is proved correct with respect to the typing system.   1. Introduction Type discipline helps programmers not only in writing type-correct programs but especially in writing them in a principled and clear way. Concurrent programming, however, has long lacked such discipline, in contrast to functional and algebraic frameworks i...},
  author = {Vasconcelos, Vasco Thudichum and Honda, Kohei},
  booktitle = {In 4th {{International Conference}} on {{Concurrency Theory}}, Volume 715 of {{LNCS}}},
  file = {/home/uma/.zotero/data/storage/7JFIF65X/Vasconcelos and Honda - 1992 - Principal Typing-Schemes in a Polyadic π-Calculus.pdf;/home/uma/.zotero/data/storage/UY624LC9/summary.html},
  pages = {524--538},
  publisher = {{Springer-Verlag}},
  title = {Principal {{Typing}}-{{Schemes}} in a {{Polyadic}} {$\pi$}-{{Calculus}}},
  year = {1992}
}

@incollection{Vasconcelos2009,
  author = {Vasconcelos, Vasco},
  booktitle = {Information and {{Computation}}},
  doi = {10.1007/978-3-642-01918-0_4},
  file = {/home/uma/references/papers/Vasconcelos_2009_Fundamentals of Session Types.pdf},
  month = may,
  pages = {158-186},
  title = {Fundamentals of {{Session Types}}},
  volume = {217},
  year = {2009}
}

@article{Voinea,
  abstract = {Multiparty Session Types (MPST) are a type formalism used to model communication protocols among components in distributed systems, by specifying type and direction of data transmitted. It is standard for multiparty session type systems to use access control based on linear or affine types. While useful in offering strong guarantees of communication safety and session fidelity, linearity and affinity run into the well-known problem of inflexible programming, excluding scenarios that make use of shared channels or need to store channels into shared data structures.},
  author = {Voinea, A Laura and Dardha, Ornela and Gay, Simon J},
  file = {/home/uma/references/papers/Voinea et al_Resource Sharing via Capability-Based Multiparty Session Types.pdf},
  language = {en},
  pages = {26},
  title = {Resource {{Sharing}} via {{Capability}}-{{Based Multiparty Session Types}}}
}

@book{Wadler1989,
  abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds\&\#039; abstraction theorem for the polymorphic lambda calculus.},
  author = {Wadler, Philip},
  title = {Theorems for {{Free}}!},
  year = {1989}
}

@article{Wadler2003,
  author = {Wadler, Philip},
  doi = {10.1007/3-540-57182-5_12},
  file = {/home/uma/references/papers/Wadler_2003_A Taste of Linear Logic.pdf},
  month = nov,
  title = {A {{Taste}} of {{Linear Logic}}},
  year = {2003}
}

@article{Wadler2014,
  author = {Wadler, Philip},
  doi = {10.1017/S095679681400001X},
  file = {/home/uma/references/papers/Wadler_2014_Propositions as Sessions.pdf;/home/uma/references/papers/Wadler_2014_Propositions as Sessions2.pdf},
  journal = {Journal of Functional Programming},
  number = {2-3},
  pages = {384-418},
  title = {Propositions as {{Sessions}}},
  volume = {24},
  year = {2014}
}

@book{Walker1989,
  author = {Walker, David and Milner, Robin and Parrow, Joachim},
  file = {/home/uma/references/papers/Walker et al_1989_A Calculus of Mobile Processes (Parts I and II).pdf},
  month = jun,
  title = {A {{Calculus}} of {{Mobile Processes}} ({{Parts I}} and {{II}})},
  volume = {100},
  year = {1989}
}

@unpublished{Wing2002,
  author = {Wing, Jeannette M.},
  file = {/home/uma/references/papers/Wing_2002_FAQ on Pi-Calculus.pdf},
  month = dec,
  title = {{{FAQ}} on {{Pi}}-{{Calculus}}},
  year = {2002}
}

@article{Xi2016,
  abstract = {We present a formalization of session types in a multi-threaded lambda-calculus (MTLC) equipped with a linear type system, establishing for the MTLC both type preservation and global progress. The latter (global progress) implies that the evaluation of a well-typed program in the MTLC can never reach a deadlock. As this formulated MTLC can be readily embedded into ATS, a full-fledged language with a functional programming core that supports both dependent types (of DML-style) and linear types, we obtain a direct implementation of session types in ATS. In addition, we gain immediate support for a form of dependent session types based on this embedding into ATS. Compared to various existing formalizations of session types, we see the one given in this paper is unique in its closeness to concrete implementation. In particular, we report such an implementation ready for practical use that generates Erlang code from well-typed ATS source (making use of session types), thus taking great advantage of the infrastructural support for distributed computing in Erlang.},
  archivePrefix = {arXiv},
  author = {Xi, Hongwei and Ren, Zhiqiang and Wu, Hanwen and Blair, William},
  eprint = {1603.03727},
  eprinttype = {arxiv},
  file = {/home/uma/references/papers/Xi et al_2016_Session Types in a Linearly Typed Multi-Threaded Lambda-Calculus.pdf},
  journal = {arXiv:1603.03727 [cs]},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  language = {en},
  month = mar,
  primaryClass = {cs},
  title = {Session {{Types}} in a {{Linearly Typed Multi}}-{{Threaded Lambda}}-{{Calculus}}},
  year = {2016}
}

@article{Xi2017,
  author = {Xi, Hongwei},
  month = mar,
  title = {Applied {{Type System}}: {{An Approach}} to {{Practical Programming}} with {{Theorem}}-{{Proving}}},
  year = {2017}
}

@inproceedings{Yang2006,
  abstract = {In this paper we present an automatic verification technique for pa- rameterized systems where the subsystem behavior is modeled using the - calculus. At its core, our technique treats each process instance in a system as a property transformer. Given a property ' that we want to verify of an N -process system, we use a partial model checker to infer the property '0 (stated as a for- mula in a sufficiently rich logic) that must hold of an (N 1)-process system. If the sequence of formulas ','0,... thus constructed converges, and the limit is satisfied by the deadlocked process, we can conclude that the N -process system satisfies '. To this end, we develop a partial model checker for the -calculus that uses an expressive value-passing logic as the property language. We also develop a number of optimizations to make the model checker efficient enough for routine use, and a light-weight widening operator to accelerate convergence. We demon- strate the effectiveness of our technique by using it to verify properties of a wide variety of parameterized systems that are beyond the reach of existing techniques.},
  author = {Yang, Ping and Basu, Samik and R. Ramakrishnan, C},
  doi = {10.1007/11691372_3},
  file = {/home/uma/references/papers/Yang et al_2006_Parameterized Verification of π-Calculus Systems.pdf},
  month = mar,
  pages = {42-57},
  title = {Parameterized {{Verification}} of {$\pi$}-{{Calculus Systems}}},
  year = {2006}
}

@phdthesis{Zalakain2018,
  abstract = {The Curry-Howard correspondence draws a direct link between logic and computation: propositions are modelled as types and proofs as programs; to prove a proposition is to construct a program inhabiting its corresponding type. Several computer-assisted theorem provers have been developed under this idea. They are not just used to verify human reasoning: they are also often capable of generating proofs automatically.

This project considers the development of such automated theorem provers in Agda, a dependently typed programming language. As a warm-up, I present a verified solver for equations on monoids. Then, I comment on the solver for commutative rings included in Agda's standard library. Finally, I develop a verified decision procedure for Presburger arithmetic \textemdash{} a decidable first-order predicate logic.},
  address = {{Glasgow}},
  author = {Zalakain, Uma},
  copyright = {Creative Commons Attribution-NoDerivatives 4.0 International License (CC-BY-ND)},
  file = {/home/uma/references/papers/Zalakain_2018_Evidence-providing problem solvers in Agda.pdf},
  language = {English},
  school = {University of Strathclyde},
  title = {Evidence-Providing Problem Solvers in {{Agda}}},
  type = {Dissertation},
  year = {2018}
}

@misc{zotero-357,
  howpublished = {https://www.cs.bham.ac.uk/\textasciitilde{}mhe/HoTT-UF-in-Agda-Lecture-Notes/index.html},
  keywords = {agda},
  title = {Introduction to {{Univalent Foundations}} of {{Mathematics}} with {{Agda}}}
}

@misc{zotero-358,
  howpublished = {https://www.um.edu.mt/projects/behapi/behapi-workshop-etaps-2019/},
  keywords = {sessiontypes},
  title = {{{BehAPI Workshop}} @ {{ETAPS}} 2019 \textendash{} {{BehAPI}}}
}

@misc{zotero-359,
  howpublished = {https://plfa.github.io/},
  keywords = {agda},
  title = {Programming {{Language Foundations}} in {{Agda}}}
}

@misc{zotero-360,
  howpublished = {https://doisinkidney.com/posts/2019-04-17-cubical-probability.html},
  keywords = {agda},
  title = {Probability {{Monads}} in {{Cubical Agda}} - {{Donnacha Ois{\'i}n Kidney}}}
}

@misc{zotero-361,
  howpublished = {https://github.com/peterthiemann/definitional-session/},
  keywords = {agda,sessiontypes},
  title = {Session Types in {{Agda}}}
}

@misc{zotero-362,
  abstract = {WATCHING},
  howpublished = {https://www.youtube.com/watch?v=eC1k0CEUO6E\&list=PLo61mJSqK5cWnrvfIcn89amVRgN9llVJG},
  keywords = {linearity},
  title = {Linear Logic Lectures}
}

@misc{zotero-363,
  abstract = {PENDING},
  howpublished = {https://www.youtube.com/watch?v=R7pJDDNy--k},
  keywords = {linearity,sessiontypes},
  title = {Linear {{Logic}}, {{Session Types}} and {{Deadlock}}-{{Freedom}}}
}

@misc{zotero-364,
  howpublished = {https://www.youtube.com/watch?v=1AYxMbYZQ1Y},
  keywords = {research},
  title = {How to Write a Great Research Paper}
}

@misc{zotero-365,
  abstract = {This lump of Agda is a talk I gave at the Scottish Programming Languages Seminar, some Wednesday last term at Heriot-Watt, in a brief oasis of research activity. I originally wrote it in my notebook coming back from Arran on the ferry, sometime in 2013 (or was it earlier?), chatting with Peter Hancock. As for\ldots{}},
  howpublished = {https://pigworker.wordpress.com/2015/01/04/traffic-dependent-session-types/},
  keywords = {dependenttypes,sessiontypes},
  title = {Traffic-Dependent Session Types | Pigworker in a Space}
}

@misc{zotero-366,
  abstract = {Typed DSLs for sorting. Contribute to bobatkey/sorting-types development by creating an account on GitHub.},
  howpublished = {https://github.com/bobatkey/sorting-types},
  title = {{{GitHub}} - Bobatkey/Sorting-Types: {{Typed DSLs}} for Sorting}
}

@misc{zotero-367,
  abstract = {Equational Reasoning in Coq, using tactics inside terms! - EquationalReasoning.v},
  howpublished = {https://gist.github.com/gallais/f046bcc2c348c5fed5e9},
  keywords = {coq,ltac},
  title = {Equational {{Reasoning}} in {{Coq}}, Using Tactics inside Terms! {$\cdot$} {{GitHub}}}
}

@misc{zotero-368,
  keywords = {check},
  title = {Untyped Lambda Calculus \textemdash{} Showing That Omega  Diverges}
}

@misc{zotero-391,
  file = {/home/uma/.zotero/data/storage/RQJ59TW7/pi-calculus.html},
  howpublished = {https://users.dimi.uniud.it/\textasciitilde{}ivan.scagnetto/pi-calculus.html},
  title = {Pi-{{Calculus}} in ({{Co}}){{Inductive Type Theory}}}
}

@misc{zotero-415,
  file = {/home/uma/.zotero/data/storage/C79KN2N2/605DA26DDDE9B1CCD35D33D0D62DF20C.html},
  howpublished = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/div-classtitlelinear-type-theory-for-asynchronous-session-typesdiv/605DA26DDDE9B1CCD35D33D0D62DF20C},
  title = {Linear Type Theory for Asynchronous Session Types | {{Journal}} of {{Functional Programming}} | {{Cambridge Core}}}
}

@misc{zotero-454,
  file = {/home/uma/.zotero/data/storage/WTWE7JQI/why-must-inductive-types-be-strictly-positive.html},
  howpublished = {https://vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive/},
  title = {Why Must Inductive Types Be Strictly Positive? \textendash{} {{Code}} and Stuff}
}

@misc{zotero-458,
  file = {/home/uma/.zotero/data/storage/LKYAKVAY/atypeofprogramming.com.html},
  howpublished = {https://atypeofprogramming.com/},
  title = {A {{Type}} of {{Programming}}}
}

@misc{zotero-549,
  file = {/home/uma/.zotero/data/storage/5SRCA3UC/proving-the-church-rosser-theorem.html},
  keywords = {check},
  language = {en-US},
  title = {Proving the {{Church}}-{{Rosser Theorem Using}} a {{Locally Nameless Representation}} | Niche Computing Science}
}


